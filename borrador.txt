Se reproduce (mitosis).
Compite por nutrientes.
Muere por falta de recursos o antibiÃ³ticos.
Puede mutar (resistencia).
Funciona sobre una grilla 2D.
Involucra eventos estocÃ¡sticos (random).
Incluye visualizaciÃ³n (grÃ¡ficos y GUI)
Genera un archivo CSV y grÃ¡ficas.
Usa control de versiones con al menos 20 commits.
SerÃ¡ defendido oralmente.

MÃ³dulos y Clases (mÃ­nimo requerido)

    Bacteria
    Atributos: id, raza, energia, resistente, estado
    MÃ©todos: alimentar(), dividirse(), mutar(), morir()

    Ambiente
    Atributos: grilla, nutrientes, factor_ambiental
    MÃ©todos: actualizar_nutrientes(), difundir_nutrientes(), aplicar_ambiente()

    Colonia
    Atributos: bacterias, ambiente
    MÃ©todos: paso(), reporte_estado(), exportar_csv()

    Simulador
    MÃ©todos: run(pasos), graficar_crecimiento(), graficar_resistencia()

    Main
    Punto de entrada que inicializa parÃ¡metros y corre la simulaciÃ³n.

    Interfaz grÃ¡fica (API GUI)
    PodrÃ­as usar: tkinter, PyQt, o GTK (si estÃ¡s en Linux). Puedes empezar solo con consola y migrar a GUI mÃ¡s adelante.

ğŸªœ PLAN DE ACCIÃ“N PASO A PASO
ğŸ§± Fase 1: Modelado base (OOP) â€“ [âš ï¸ Avance 1: antes del 18 de junio]

    DiseÃ±a clases Bacteria, Ambiente y Colonia con atributos y mÃ©todos bÃ¡sicos.

        Usa docstrings y prueba mÃ©todos de forma unitaria.

        Simula consumo, muerte y divisiÃ³n sin visualizaciÃ³n aÃºn.

    Crea una grilla simple (por ejemplo, numpy.zeros((10,10)))

        Posiciona bacterias al azar.

        Relaciona posiciones con objetos Bacteria.

    Aplica eventos bÃ¡sicos por paso:

        Cada paso: alimentar bacterias â†’ verificar divisiÃ³n â†’ aplicar muertes.

    Agrega mutaciÃ³n probabilÃ­stica (5%) al dividirse.

        Usa random.random().

    Introduce factor ambiental (ej. antibiÃ³tico)

        Usa ejemplo aplicar_antibiotico(bacteria).

    Genera reporte_estado() en consola.

âœ… Al final de esta fase, deberÃ­as tener una simulaciÃ³n por consola funcional sin interfaz grÃ¡fica.
ğŸ§® Fase 2: VisualizaciÃ³n bÃ¡sica (matplotlib + CSV) â€“ [âš ï¸ Avance 2: antes del 25 de junio]

    Crea funciÃ³n graficar_grilla() con matplotlib, como el ejemplo del enunciado.

    Implementa graficar_crecimiento() y graficar_resistencia()

        Guarda los datos por paso en listas o un DataFrame.

    Genera archivo CSV con informaciÃ³n relevante

        Ejemplo: id, estado, energia, raza, resistencia, posiciÃ³n.

âœ… AquÃ­ deberÃ­as tener una simulaciÃ³n que se ejecuta por pasos, genera grÃ¡ficos y archivos de salida.
ğŸ–¼ï¸ Fase 3: Interfaz grÃ¡fica (API GUI)

    Crea ventana principal con:

        BotÃ³n "Iniciar SimulaciÃ³n"

        Entrada para nÃºmero de pasos

        Grilla visualizable (puede embedirse matplotlib o usar Canvas)

    Integra lÃ³gica de simulaciÃ³n con la GUI

        Usa threading si es necesario para no congelar la interfaz.

âœ… Una GUI bÃ¡sica funcional es suficiente, pero puedes mejorarla segÃºn el tiempo disponible.
ğŸ› ï¸ Fase 4: Pulido y defensa

    Refactoriza y comenta todo el cÃ³digo.

    Agrega logs, prints informativos o barras de estado.

    Haz pruebas con distintos parÃ¡metros y documenta observaciones.

    Prepara defensa:

        Explica el modelo de clases.

        Justifica decisiones probabilÃ­sticas y biolÃ³gicas.

        Muestra outputs (grÃ¡ficos, CSV, GUI).

-------------------------------------------------------------------

| AcciÃ³n                                       | Â¿Comentario en cÃ³digo? | Â¿Commit con mensaje? |
| -------------------------------------------- | ---------------------- | -------------------- |
| Explicar quÃ© hace una funciÃ³n                | âœ… SÃ­                   | ğŸš« No                |
| Decir â€œesto estÃ¡ pendienteâ€                  | âœ… SÃ­ (`# TODO`)        | ğŸš« No                |
| Guardar que agregaste una clase nueva        | ğŸš« No                  | âœ… SÃ­                 |
| Anotar cambios importantes                   | âœ… SÃ­                   | âœ… SÃ­                 |
| Documentar la lÃ³gica de una fÃ³rmula compleja | âœ… SÃ­                   | ğŸš« No                |
| Registrar que hiciste la interfaz grÃ¡fica    | ğŸš« No                  | âœ… SÃ­                 |


Inicializar repositorio y estructura del proyecto
Crear clase Bacteria con atributos bÃ¡sicos
Agregar mÃ©todo alimentar()
Agregar mÃ©todo dividirse() con lÃ³gica de energÃ­a
Agregar clase Ambiente con nutrientes
Agregar clase Colonia que controla bacterias
Implementar paso de simulaciÃ³n
Visualizar grilla con matplotlib
Agregar lÃ³gica de muerte por inaniciÃ³n
Agregar presiÃ³n ambiental con antibiÃ³tico
Implementar mutaciÃ³n y resistencia
AÃ±adir eventos con random
Crear exportaciÃ³n CSV con estado por paso
Graficar crecimiento de la colonia
Graficar evoluciÃ³n de bacterias resistentes
Integrar visualizaciÃ³n de la grilla en GUI
DiseÃ±ar interfaz grÃ¡fica bÃ¡sica
BotÃ³n para correr simulaciÃ³n desde GUI
Documentar cÃ³digo y limpiar comentarios
Ajustes finales para entrega

-----------------------------------------------------------------

""""Bacteria
id: identificador Â´unico.
raza: identificador genÂ´etico o especie.
energia: nivel de energÂ´Ä±a actual.
resistente: booleano que indica si es resistente.
estado: activa o muerta.
MÂ´etodos: alimentar(), dividirse(), mutar(), morir()."""

### CLASE Bacteria
class Bacteria:
    def __init__(self, id_bacteria, raza, energia, resistente, estado):
        self.__id = id_bacteria
        self.__raza = raza
        self.__energia = energia
        self.__resistente = resistente
        self.__estado = estado

    def get_id(self):
        return self.__id

    def get_raza(self):
        return self.__raza

    def get_energia(self):
        return self.__energia

    def set_energia(self, valor):
        self.__energia = valor

    def es_resistente(self):
        return self.__resistente

    def set_resistente(self, valor):
        self.__resistente = valor

    def get_estado(self):
        return self.__estado

    def set_estado(self, valor):
        self.__estado = valor

    def __str__(self):
        return f"Bacteria(id={self.__id}, raza={self.__raza}, energia={self.__energia}, resistente={self.__resistente}, estado={self.__estado})"


"""Ambiente
grilla: matriz que representa el entorno.
nutrientes: cantidad de nutrientes por celda.
factor ambiental: puede representar antibiÂ´oticos u otras presiones.
MÂ´etodos: actualizar nutrientes(), difundir nutrientes(), aplicar ambiente()"""

### CLASE Ambiente
class Ambiente:
    def __init__(self, grilla, nutrientes, factor_ambiental):
        self.__grilla = grilla
        self.__nutrientes = nutrientes
        self.__factor_ambiental = factor_ambiental

    def get_grilla(self):
        return self.__grilla

    def get_nutrientes(self):
        return self.__nutrientes

    def set_nutrientes(self, matriz):
        self.__nutrientes = matriz

    def get_factor_ambiental(self):
        return self.__factor_ambiental

    def set_factor_ambiental(self, valor):
        self.__factor_ambiental = valor

    def __str__(self):
        return f"Ambiente(grilla=matriz_{len(self.__grilla)}x{len(self.__grilla[0])}, factor={self.__factor_ambiental})"


"""Colonia
bacterias: lista de objetos Bacteria.
ambiente: instancia de la clase Ambiente.
MÂ´etodos: paso(), reporte estado(), exportar csv()"""

### CLASE Colonia
class Colonia:
    def __init__(self, bacterias, ambiente):
        self.__bacterias = bacterias
        self.__ambiente = ambiente

    def get_bacterias(self):
        return self.__bacterias

    def get_ambiente(self):
        return self.__ambiente

    def __str__(self):
        return f"Colonia(Bacterias={len(self.__bacterias)}, Ambiente={self.__ambiente})"


"""Simulador
Controla los pasos de simulaciÂ´on e inicializa los valores.
MÂ´etodos: run(pasos), graficar crecimiento(), graficar resistencia()."""

### CLASE Simulador
class Simulador:
    def __init__(self, colonia):
        self.__colonia = colonia

    def get_colonia(self):
        return self.__colonia

    def __str__(self):
        return f"Simulador({self.__colonia})"




"""""""""""""

# CLASE Ambiente
class Ambiente:
    def __init__(self):
        self.razas_disponibles = ["cocos", "bacilos", "espirilos"]
        self.grilla = np.empty((5, 5), dtype=object)
        self.nutrientes = np.full((5, 5), 100)
        self.contador_pasos = 0
        self.factor_ambiental = 0.2  # puede representar antibiÃ³ticos u otras presiones

    def grilla_objetos(self):
        i, j = random.randint(0,4), random.randint(0,4)
        raza = random.choice(self.razas_disponibles)
        energia = random.randint(20, 100)
        resistente = random.choice([True, False])
        estado = "activa"
        id_bacteria = f"{raza}_{i}_{j}"
        self.grilla[i, j] = Bacteria(id_bacteria, raza, energia, resistente, estado)

    def actualizar_nutrientes(self):
        # RegeneraciÃ³n aleatoria parcial de nutrientes
        self.nutrientes += np.random.randint(0, 3, size=(5, 5))
        self.nutrientes = np.clip(self.nutrientes, 0, 100)

    def difundir_nutrientes(self):
        nueva = self.nutrientes.copy()
        for i in range(5):
            for j in range(5):
                vecinos = [(i+di, j+dj) for di, dj in [(-1,0),(1,0),(0,-1),(0,1)] if 0 <= i+di < 5 and 0 <= j+dj < 5]
                promedio = sum(self.nutrientes[vi, vj] for vi, vj in vecinos) // len(vecinos)
                nueva[i, j] = (self.nutrientes[i, j] + promedio) // 2
        self.nutrientes = nueva

    def aplicar_ambiente(self):
        self.actualizar_nutrientes()
        self.difundir_nutrientes()

    def sincronizar_visual(self):
        self.grilla_visual = np.zeros((5, 5))
        for i in range(5):
            for j in range(5):
                bacteria = self.grilla[i, j]
                if bacteria is None:
                    self.grilla_visual[i, j] = 0
                elif bacteria.get_estado() == "inactiva":
                    self.grilla_visual[i, j] = 2
                elif bacteria.get_estado() == "activa" and bacteria.get_resistente():
                    self.grilla_visual[i, j] = 3
                elif bacteria.get_estado() == "activa" and not bacteria.get_resistente():
                    self.grilla_visual[i, j] = 1

    def graficar_grilla(self):
        self.contador_pasos += 1
        nombre_archivo = f"grilla_colonia_paso_{self.contador_pasos}.png"
        # Se define un mapa de colores personalizado (verde, rojo, azul)
        colores = {
            0: "white",  # celda vacÃ­a
            1: "green",  # activa no resistente
            2: "red",    # inactiva
            3: "blue"    # activa resistente
        }

        fig, ax = plt.subplots(figsize=(5,5))
        matriz_color = np.empty_like(self.grilla_visual, dtype=object)
        for i in range(5):
            for j in range(5):
                val = self.grilla_visual[i, j]
                matriz_color[i, j] = colores.get(val, "gray")

        ax.imshow(matriz_color, interpolation='none')

        # Se mejora la leyenda con colores explÃ­citos
        legend_elements = [
            Patch(facecolor='green', label='Activa no resistente'),
            Patch(facecolor='red', label='Inactiva'),
            Patch(facecolor='blue', label='Activa resistente'),
        ]
        ax.legend(handles=legend_elements, loc='upper right', bbox_to_anchor=(1.5, 1))

        ax.set_xticks(np.arange(0, 5, 1))
        ax.set_yticks(np.arange(0, 5, 1))
        ax.set_xticklabels([])
        ax.set_yticklabels([])
        ax.grid(color='gray', linestyle='-', linewidth=0.5)

        # Texto en cada celda
        for i in range(5):
            for j in range(5):
                val = self.grilla_visual[i, j]
                if val > 0:
                    ax.text(j, i, int(val), va='center', ha='center', color='white', fontsize=12)

        plt.title("  Colonia bacteriana (5x5)   ")
        plt.tight_layout()
        plt.savefig(nombre_archivo)
        plt.close()
        self.nombre_ultima_imagen = nombre_archivo
