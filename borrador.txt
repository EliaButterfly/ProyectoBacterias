Se reproduce (mitosis).
Compite por nutrientes.
Muere por falta de recursos o antibióticos.
Puede mutar (resistencia).
Funciona sobre una grilla 2D.
Involucra eventos estocásticos (random).
Incluye visualización (gráficos y GUI)
Genera un archivo CSV y gráficas.
Usa control de versiones con al menos 20 commits.
Será defendido oralmente.

Módulos y Clases (mínimo requerido)

    Bacteria
    Atributos: id, raza, energia, resistente, estado
    Métodos: alimentar(), dividirse(), mutar(), morir()

    Ambiente
    Atributos: grilla, nutrientes, factor_ambiental
    Métodos: actualizar_nutrientes(), difundir_nutrientes(), aplicar_ambiente()

    Colonia
    Atributos: bacterias, ambiente
    Métodos: paso(), reporte_estado(), exportar_csv()

    Simulador
    Métodos: run(pasos), graficar_crecimiento(), graficar_resistencia()

    Main
    Punto de entrada que inicializa parámetros y corre la simulación.

    Interfaz gráfica (API GUI)
    Podrías usar: tkinter, PyQt, o GTK (si estás en Linux). Puedes empezar solo con consola y migrar a GUI más adelante.

🪜 PLAN DE ACCIÓN PASO A PASO
🧱 Fase 1: Modelado base (OOP) – [⚠️ Avance 1: antes del 18 de junio]

    Diseña clases Bacteria, Ambiente y Colonia con atributos y métodos básicos.

        Usa docstrings y prueba métodos de forma unitaria.

        Simula consumo, muerte y división sin visualización aún.

    Crea una grilla simple (por ejemplo, numpy.zeros((10,10)))

        Posiciona bacterias al azar.

        Relaciona posiciones con objetos Bacteria.

    Aplica eventos básicos por paso:

        Cada paso: alimentar bacterias → verificar división → aplicar muertes.

    Agrega mutación probabilística (5%) al dividirse.

        Usa random.random().

    Introduce factor ambiental (ej. antibiótico)

        Usa ejemplo aplicar_antibiotico(bacteria).

    Genera reporte_estado() en consola.

✅ Al final de esta fase, deberías tener una simulación por consola funcional sin interfaz gráfica.
🧮 Fase 2: Visualización básica (matplotlib + CSV) – [⚠️ Avance 2: antes del 25 de junio]

    Crea función graficar_grilla() con matplotlib, como el ejemplo del enunciado.

    Implementa graficar_crecimiento() y graficar_resistencia()

        Guarda los datos por paso en listas o un DataFrame.

    Genera archivo CSV con información relevante

        Ejemplo: id, estado, energia, raza, resistencia, posición.

✅ Aquí deberías tener una simulación que se ejecuta por pasos, genera gráficos y archivos de salida.
🖼️ Fase 3: Interfaz gráfica (API GUI)

    Crea ventana principal con:

        Botón "Iniciar Simulación"

        Entrada para número de pasos

        Grilla visualizable (puede embedirse matplotlib o usar Canvas)

    Integra lógica de simulación con la GUI

        Usa threading si es necesario para no congelar la interfaz.

✅ Una GUI básica funcional es suficiente, pero puedes mejorarla según el tiempo disponible.
🛠️ Fase 4: Pulido y defensa

    Refactoriza y comenta todo el código.

    Agrega logs, prints informativos o barras de estado.

    Haz pruebas con distintos parámetros y documenta observaciones.

    Prepara defensa:

        Explica el modelo de clases.

        Justifica decisiones probabilísticas y biológicas.

        Muestra outputs (gráficos, CSV, GUI).

-------------------------------------------------------------------

| Acción                                       | ¿Comentario en código? | ¿Commit con mensaje? |
| -------------------------------------------- | ---------------------- | -------------------- |
| Explicar qué hace una función                | ✅ Sí                   | 🚫 No                |
| Decir “esto está pendiente”                  | ✅ Sí (`# TODO`)        | 🚫 No                |
| Guardar que agregaste una clase nueva        | 🚫 No                  | ✅ Sí                 |
| Anotar cambios importantes                   | ✅ Sí                   | ✅ Sí                 |
| Documentar la lógica de una fórmula compleja | ✅ Sí                   | 🚫 No                |
| Registrar que hiciste la interfaz gráfica    | 🚫 No                  | ✅ Sí                 |


Inicializar repositorio y estructura del proyecto
Crear clase Bacteria con atributos básicos
Agregar método alimentar()
Agregar método dividirse() con lógica de energía
Agregar clase Ambiente con nutrientes
Agregar clase Colonia que controla bacterias
Implementar paso de simulación
Visualizar grilla con matplotlib
Agregar lógica de muerte por inanición
Agregar presión ambiental con antibiótico
Implementar mutación y resistencia
Añadir eventos con random
Crear exportación CSV con estado por paso
Graficar crecimiento de la colonia
Graficar evolución de bacterias resistentes
Integrar visualización de la grilla en GUI
Diseñar interfaz gráfica básica
Botón para correr simulación desde GUI
Documentar código y limpiar comentarios
Ajustes finales para entrega

-----------------------------------------------------------------

""""Bacteria
id: identificador ´unico.
raza: identificador gen´etico o especie.
energia: nivel de energ´ıa actual.
resistente: booleano que indica si es resistente.
estado: activa o muerta.
M´etodos: alimentar(), dividirse(), mutar(), morir()."""

### CLASE Bacteria
class Bacteria:
    def __init__(self, id_bacteria, raza, energia, resistente, estado):
        self.__id = id_bacteria
        self.__raza = raza
        self.__energia = energia
        self.__resistente = resistente
        self.__estado = estado

    def get_id(self):
        return self.__id

    def get_raza(self):
        return self.__raza

    def get_energia(self):
        return self.__energia

    def set_energia(self, valor):
        self.__energia = valor

    def es_resistente(self):
        return self.__resistente

    def set_resistente(self, valor):
        self.__resistente = valor

    def get_estado(self):
        return self.__estado

    def set_estado(self, valor):
        self.__estado = valor

    def __str__(self):
        return f"Bacteria(id={self.__id}, raza={self.__raza}, energia={self.__energia}, resistente={self.__resistente}, estado={self.__estado})"


"""Ambiente
grilla: matriz que representa el entorno.
nutrientes: cantidad de nutrientes por celda.
factor ambiental: puede representar antibi´oticos u otras presiones.
M´etodos: actualizar nutrientes(), difundir nutrientes(), aplicar ambiente()"""

### CLASE Ambiente
class Ambiente:
    def __init__(self, grilla, nutrientes, factor_ambiental):
        self.__grilla = grilla
        self.__nutrientes = nutrientes
        self.__factor_ambiental = factor_ambiental

    def get_grilla(self):
        return self.__grilla

    def get_nutrientes(self):
        return self.__nutrientes

    def set_nutrientes(self, matriz):
        self.__nutrientes = matriz

    def get_factor_ambiental(self):
        return self.__factor_ambiental

    def set_factor_ambiental(self, valor):
        self.__factor_ambiental = valor

    def __str__(self):
        return f"Ambiente(grilla=matriz_{len(self.__grilla)}x{len(self.__grilla[0])}, factor={self.__factor_ambiental})"


"""Colonia
bacterias: lista de objetos Bacteria.
ambiente: instancia de la clase Ambiente.
M´etodos: paso(), reporte estado(), exportar csv()"""

### CLASE Colonia
class Colonia:
    def __init__(self, bacterias, ambiente):
        self.__bacterias = bacterias
        self.__ambiente = ambiente

    def get_bacterias(self):
        return self.__bacterias

    def get_ambiente(self):
        return self.__ambiente

    def __str__(self):
        return f"Colonia(Bacterias={len(self.__bacterias)}, Ambiente={self.__ambiente})"


"""Simulador
Controla los pasos de simulaci´on e inicializa los valores.
M´etodos: run(pasos), graficar crecimiento(), graficar resistencia()."""

### CLASE Simulador
class Simulador:
    def __init__(self, colonia):
        self.__colonia = colonia

    def get_colonia(self):
        return self.__colonia

    def __str__(self):
        return f"Simulador({self.__colonia})"




"""""""""""""

# CLASE Ambiente
class Ambiente:
    def __init__(self):
        self.razas_disponibles = ["cocos", "bacilos", "espirilos"]
        self.grilla = np.empty((5, 5), dtype=object)
        self.nutrientes = np.full((5, 5), 100)
        self.contador_pasos = 0
        self.factor_ambiental = 0.2  # puede representar antibióticos u otras presiones

    def grilla_objetos(self):
        i, j = random.randint(0,4), random.randint(0,4)
        raza = random.choice(self.razas_disponibles)
        energia = random.randint(20, 100)
        resistente = random.choice([True, False])
        estado = "activa"
        id_bacteria = f"{raza}_{i}_{j}"
        self.grilla[i, j] = Bacteria(id_bacteria, raza, energia, resistente, estado)

    def actualizar_nutrientes(self):
        # Regeneración aleatoria parcial de nutrientes
        self.nutrientes += np.random.randint(0, 3, size=(5, 5))
        self.nutrientes = np.clip(self.nutrientes, 0, 100)

    def difundir_nutrientes(self):
        nueva = self.nutrientes.copy()
        for i in range(5):
            for j in range(5):
                vecinos = [(i+di, j+dj) for di, dj in [(-1,0),(1,0),(0,-1),(0,1)] if 0 <= i+di < 5 and 0 <= j+dj < 5]
                promedio = sum(self.nutrientes[vi, vj] for vi, vj in vecinos) // len(vecinos)
                nueva[i, j] = (self.nutrientes[i, j] + promedio) // 2
        self.nutrientes = nueva

    def aplicar_ambiente(self):
        self.actualizar_nutrientes()
        self.difundir_nutrientes()

    def sincronizar_visual(self):
        self.grilla_visual = np.zeros((5, 5))
        for i in range(5):
            for j in range(5):
                bacteria = self.grilla[i, j]
                if bacteria is None:
                    self.grilla_visual[i, j] = 0
                elif bacteria.get_estado() == "inactiva":
                    self.grilla_visual[i, j] = 2
                elif bacteria.get_estado() == "activa" and bacteria.get_resistente():
                    self.grilla_visual[i, j] = 3
                elif bacteria.get_estado() == "activa" and not bacteria.get_resistente():
                    self.grilla_visual[i, j] = 1

    def graficar_grilla(self):
        self.contador_pasos += 1
        nombre_archivo = f"grilla_colonia_paso_{self.contador_pasos}.png"
        # Se define un mapa de colores personalizado (verde, rojo, azul)
        colores = {
            0: "white",  # celda vacía
            1: "green",  # activa no resistente
            2: "red",    # inactiva
            3: "blue"    # activa resistente
        }

        fig, ax = plt.subplots(figsize=(5,5))
        matriz_color = np.empty_like(self.grilla_visual, dtype=object)
        for i in range(5):
            for j in range(5):
                val = self.grilla_visual[i, j]
                matriz_color[i, j] = colores.get(val, "gray")

        ax.imshow(matriz_color, interpolation='none')

        # Se mejora la leyenda con colores explícitos
        legend_elements = [
            Patch(facecolor='green', label='Activa no resistente'),
            Patch(facecolor='red', label='Inactiva'),
            Patch(facecolor='blue', label='Activa resistente'),
        ]
        ax.legend(handles=legend_elements, loc='upper right', bbox_to_anchor=(1.5, 1))

        ax.set_xticks(np.arange(0, 5, 1))
        ax.set_yticks(np.arange(0, 5, 1))
        ax.set_xticklabels([])
        ax.set_yticklabels([])
        ax.grid(color='gray', linestyle='-', linewidth=0.5)

        # Texto en cada celda
        for i in range(5):
            for j in range(5):
                val = self.grilla_visual[i, j]
                if val > 0:
                    ax.text(j, i, int(val), va='center', ha='center', color='white', fontsize=12)

        plt.title("  Colonia bacteriana (5x5)   ")
        plt.tight_layout()
        plt.savefig(nombre_archivo)
        plt.close()
        self.nombre_ultima_imagen = nombre_archivo
